在该文件中，**凸包的上下边界（`upperIndices` 和 `lowerIndices`）可以形象地理解为“扫描线推进过程中，当前可见区域的上沿和下沿轮廓”**。

---

## 一、从图形角度形象理解

想象你正在用一条**垂直的扫描线**从左到右扫过整个二维平面：

- 扫描线碰到的第一个点是“最左边”的点；
- 随着扫描线向右移动，它会遇到越来越多的点和边；
- 在任意时刻，扫描线左侧已经处理过的点构成了一个或多个“可见区域”；
- 每个可见区域都有：
  - **上边界（upper boundary）**
  - **下边界（lower boundary）**

这些边界就是由 `PartialHull` 中的 `upperIndices` 和 `lowerIndices` 来记录的。

---

## 二、动画类比：像窗帘一样展开

你可以把每个 `PartialHull` 想象成一对“窗帘”，它们从左右两侧逐步展开：

| 元素 | 类比 |
|------|------|
| `upperIndices` | 上层窗帘的边缘轨迹 |
| `lowerIndices` | 下层窗帘的边缘轨迹 |
| `addPoint()`   | 新的点插入时，窗帘边缘被拉伸或裁剪 |
| `splitHulls()` | 窗帘被剪开，分成两段 |
| `mergeHulls()` | 窗帘重新缝合 |

每当一个新的点被加入，就相当于在窗帘边缘添加一个新褶皱，并尝试将这个褶皱与前两个褶皱组成一个三角形（即生成一个三角面片）。

---

## 三、几何意义：上下边界构成单调多边形的“骨架”

- 单调多边形的一个关键特性是：其相对于某条方向线（如水平线）最多有两个交点；
- 所以当扫描线从左向右推进时，我们可以维护两条折线：
  - **上边界折线（upper polyline）**
  - **下边界折线（lower polyline）**
- 这两条折线共同构成了当前可见多边形的“骨架”；
- 每新增一个点，就尝试将其连接到这两条折线上，并判断是否能形成合法的三角形；
- 如果不能，则说明需要“剪掉”一些旧的点，形成新的结构。

---

## 四、代码中的具体体现

在 `addPoint()` 函数中：

```ts
while (m > 1 && orient(points[lowerIndices[m - 2]], points[lowerIndices[m - 1]], p) > 0) {
    cells.push([lowerIndices[m - 1], lowerIndices[m - 2], idx])
    m -= 1
}
```

这段代码的意思是：

> “如果当前点 `p` 和 `lowerIndices` 最后两个点构成的是一个顺时针三角形，就把它加入结果中。”

这实际上就是在判断：**当前点是否破坏了下边界的“单调性”？如果不满足单调条件，就剪裁出一个三角形，保持结构合法。**

同理，对 `upperIndices` 的判断则是判断逆时针方向。

---

## 五、总结类比图示（文字版）

```
扫描线 →
        |
        |     upperIndices: [A, B, C]
        |         ↖     ↖     ↖
        |          A —— B —— C
        |                     \
        |                      \
        |                       P ← 当前插入点
        |                      /
        |         ↙     ↙     ↙
        |       D —— E —— F
        |     lowerIndices: [D, E, F]
        |
```

在这个图中：

- 扫描线推进到了点 `P`；
- 上边界是 A-B-C；
- 下边界是 D-E-F；
- 插入点 P 后，检查是否能与 A-B-C 或 D-E-F 构成合法三角形；
- 若能，则生成 `[C, B, P]` 或 `[E, F, P]` 等三角形；
- 若不能，则更新边界数组，维持结构。

---

## 六、一句话总结

> `upperIndices` 和 `lowerIndices` 就像是扫描线推进过程中，每一步都动态维护的“上沿轮廓”和“下沿轮廓”，它们帮助我们识别何时可以安全地生成三角形，并保证整体结构始终符合单调多边形的性质。